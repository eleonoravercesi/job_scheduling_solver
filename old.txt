 /* IGNORE FROM HERE
    // Create variables x and y: 0 <= x,y <= +inf
    SCIP_VAR* x;
    SCIP_VAR* y;

    SCIP_CALL(SCIPcreateVarBasic(scip, &x, "x", 0.0, SCIPinfinity(scip), 3.0, SCIP_VARTYPE_CONTINUOUS));
    SCIP_CALL(SCIPcreateVarBasic(scip, &y, "y", 0.0, SCIPinfinity(scip), 2.0, SCIP_VARTYPE_CONTINUOUS));


    // Add variables to SCIP
    SCIP_CALL(SCIPaddVar(scip, x));
    SCIP_CALL(SCIPaddVar(scip, y));

    // Create constraint: x + y â‰¤ 10
    SCIP_CONS* cons;
    SCIP_CALL(SCIPcreateConsBasicLinear(scip, &cons, "c1", 0, nullptr, nullptr, -SCIPinfinity(scip), 10.0));
    SCIP_CALL(SCIPaddCoefLinear(scip, cons, x, 1.0));
    SCIP_CALL(SCIPaddCoefLinear(scip, cons, y, 1.0));

    // Add constraint to model
    SCIP_CALL(SCIPaddCons(scip, cons));

    // Set objective sense: maximize
    SCIP_CALL(SCIPsetObjsense(scip, SCIP_OBJSENSE_MAXIMIZE));

    // Solve the problem
    SCIP_CALL(SCIPsolve(scip));

    // Get best solution
    SCIP_SOL* sol = SCIPgetBestSol(scip);
    if (sol != nullptr) {
        std::cout << "Optimal solution found:\n";
        std::cout << "x = " << SCIPgetSolVal(scip, sol, x) << "\n";
        std::cout << "y = " << SCIPgetSolVal(scip, sol, y) << "\n";
        std::cout << "Objective value = " << SCIPgetSolOrigObj(scip, sol) << "\n";
    } else {
        std::cout << "No solution found.\n";
    }

    SCIP_CALL(SCIPreleaseCons(scip, &cons));
    SCIP_CALL(SCIPreleaseVar(scip, &x));
    SCIP_CALL(SCIPreleaseVar(scip, &y));
    SCIP_CALL(SCIPfree(&scip));

    */